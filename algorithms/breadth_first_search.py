from collections import deque

from node import Node

"""
def bfs_by_queue(root):
    queue = deque([root]):          # at least one element required
    while len(queue) > 0:           # as long as there is an element in the queue
        node = queue.pop_left()     # dequeue
        for child in node.children: # enqueue any children
            if (OK(child)):         # early return if problem condition is met
                return FOUND(child)
            queue.append(child)
    return NOT_FOUND
"""

"""
Breadth-First Search Example:

State Representation: contained within each node
(the _value_ we are searching for in this _specific_ case)

Queue: Data structure to keep track of nodes to be visited
and in the right order. Nodes generated by _Successor Function_

Visited: Set of nodes already "visited" to avoid cycles

Successor Function (or expansion rule): Logic used to determine
set of _next_ nodes to be visited. Allowed transitions or
actions within the problem domain

Goal Test: A condition to determine if the given state is
the desired state. Terminates the BFS.


"""


def bfs(root: Node, target):
    if root is None:
        return None
    q = deque()
    visited = set()

    q.append(root)
    visited.add(root)

    while len(q) > 0:
        node = q.popleft()
        left = node.left
        right = node.right
        if left is not None and left not in visited:
            if left.value == target:
                return left
            else:
                visited.add(left)
                q.append(left)
        if right is not None and right not in visited:
            if right.value == target:
                return right
            else:
                visited.add(right)
                q.append(right)
    return None


def test0():
    root = Node(1)
    result = bfs(root, 5)
    print([result.value if result is not None else "None"])


def test1():
    root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6, Node(7))))
    result = bfs(root, 5)
    print(result.value)


def test2():
    root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6, Node(7))))
    result = bfs(root, 2)
    print(result.value)


def test3():
    root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6, Node(7))))
    result = bfs(root, 24)
    print([result.value if result is not None else "None"])


def main():
    print("Breadth First Search Example")
    test0()
    test1()
    test2()
    test3()


if __name__ == "__main__":
    main()
